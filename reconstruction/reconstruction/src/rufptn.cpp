#include "rufptn.h"
#include "sddstio.h"
#include "rufptnAnalysis.h"
#include "icrr2ru.h"
#include "sdxyzclf_class.h"

int main(int argc, char **argv)
{
  char* infile       = 0;     // points to input files, for using with pullFile() function from filestack.h
  char  oflgen[0x400];        // stores output files that are auto-generated by directory and suffix substitution
  bool  have_mc;              // true when have either ICRR or Rutgers MC for a given event 
  bool  analyze;              // a given event is analyzed if this flag is true (needed banks are present) 
  bool  have_bank[2] = {0,0}; // [0] T/F having rusdraw/talex00 bank(s), [1] T/F having tasdcalibev bank
  
  // command line arguments
  listOfOpt opt;
  if (!opt.getFromCmdLine(argc, argv))
    return 2;
    
  // always print out what options are used in the analysis; and the user can't do anything to stop it
  opt.printOpts();
 
  // initialize the analysis, give it the command line options
  rufptnAnalysis* ana = new rufptnAnalysis(opt);
  
  // tasdcalibev/rusdraw converter
  icrr2ru* icr2r   = new icrr2ru;
  
  // dst event I/O, this class reads and writes events from/to dst files
  sddstio_class* dstio = new sddstio_class(opt.verbose);
  
  // allocate bank list for the banks that will be added by rufptn to the output events
  integer4 addBanks = newEmptyBankList();
    
  // provides utilities specific to the main TA SD array
  static sdxyzclf_class rufptn_sdxyzclf;
  
  // if the uses wants to have just one dst output file for all events then open it here
  if (opt.outfile[0] && !dstio->openDSToutFile(opt.outfile,opt.fOverwriteMode))
    return 2;
  
  // total number of events over all input dst files
  int  nevents_processed = 0;
  
  // number of events with SD information DST banks
  int  nevents_analyzed  = 0;
  
  // go over all (passed) dst files and analyze all events in those file
  // for every input dst file, a coressponding output file is made (with a changed suffix)
  // unless an option to write all events to one dst file is used
  while ((infile = pullFile()))
    {
      if (opt.outfile[0])
	{
	  if(!dstio->openDSTinFile(infile))
	    return 2;
	}
      else
	{
	  // To produce the output file name with correct suffix.
	  if (SDIO::makeOutFileName(infile, opt.dout, (char *) RUFPTN_DST_GZ, oflgen) != 1)
	    return 2;
	  if (!dstio->openDSTfiles(infile, oflgen, opt.fOverwriteMode))
	    return 2;
	}
	
      // Should reset the DST event number to zero each time we open a new DST file because ICRR bank doesn't store 
      // the event number information. Not very important.
      icr2r->reset_event_num();

      // loop through each event in the dst file
      while (dstio->readEvent())
	{
	    
	  // initalize the list of banks that need to be added to the output events,
	  // in addition to the banks that are being read in from the input events
	  clrBankList(addBanks);
	    
	  // true if one has the MC; some additional useful MC information is calculated (rusdmc1 bank)
	  have_mc = false;

	  // first, assume that the event is analyzable
	  analyze = true;
	    
	  // both rusdraw and talex00 work the same, but prefer rusdraw if it's available
	  have_bank[0] = dstio->haveBank(RUSDRAW_BANKID) || dstio->haveBank(TALEX00_BANKID);
	  if(dstio->haveBank(TALEX00_BANKID) && !dstio->haveBank(RUSDRAW_BANKID))
	      rufptn_sdxyzclf.talex00_2_rusdraw(&talex00_,&rusdraw_);
            
	  have_bank[1] = dstio->haveBank(TASDCALIBEV_BANKID);
	  
	  
	  // can't do much about the event if it doesn't have the basic SD informatoin
	  if (!have_bank[0] && !have_bank[1])
	    {
	      if(opt.bank_warning_opt)
		fprintf(stderr, "WARNING: both 'tasdcalibev' and 'rusdraw' banks are absent\n");
	      analyze = false;
	    }
	    
	  // also, don't analyze the event if user explicitly demanded the use of ICRR bank but tasdcalibev is absent
	  if (analyze && opt.useICRRbank && !have_bank[1])
	    {
	      if(opt.bank_warning_opt)
		fprintf(stderr, "WARNING: '-icrr' option used but 'tasdcalibev' bank is absent\n");
	      analyze = false;
	    }
	    
	  // if ICRR bank option is forced or we don't have rusdraw bank then use ICRR tasdcalibev bank,
	  // if it is available. Otherwise, use rusdraw bank.  At this point, 'analyze' should be false if 
	  // both rusdraw and tasdcalibev are absent or if one wants to use the ICRR bank but it is absent
	  if (analyze && (opt.useICRRbank || !have_bank[0]))
	    {
	      // convert to rusdraw ( and also adds rusdmc if tasdcalibev_.eventCode is zero,
	      // which means a MC event )
	      if (analyze && !icr2r->Convert())
		analyze = false;
		
	      if (analyze && !(tasdcalibev_.eventCode == 0 || tasdcalibev_.eventCode == 1))
		fprintf(stderr,"WARNING: tasdcalibev_.eventCode = %d is not supported; assuming real data event\n",
			tasdcalibev_.eventCode);
		
	      // Monte Carlo in ICRR-format when tasdcalibev_.eventCode=0
	      have_mc = (tasdcalibev_.eventCode == 0);
		
	    }
	  // Monte Carlo if rusdmc bank is present (and not using ICRR format)
	  else
	    have_mc = dstio->haveBank(RUSDMC_BANKID);

	  // if the DST bank that describes bad SDs is absent but the corresponding option is used,
	  // then zero out the bsdinfo bank for this event.
	  if(!dstio->haveBank(BSDINFO_BANKID))
	    memset(&bsdinfo_,0,sizeof(bsdinfo_dst_common));
	  
	  // if event has the necessary banks, then analyze it and add the results of the analysis
	  // to the output event banks
	  if(analyze)
	    {	
	      // by now, all variables should be set to do the analysis; analyze the event here.
	      ana->analyzeEvent();	
	
	      // calculate additional MC information from the thrown variables if we have the MC
	      if (have_mc)
		{
		  // OK to use if event triggers or doesn't trigger
		  // if the event is being analyzed and it didn't triggered, then rusdgeom bank is 
		  // zeroed out thus setting the necessary refference time to zero as well
		  ana->comp_rusdmc1();
		  addBankList(addBanks,RUSDMC_BANKID);
		  addBankList(addBanks,RUSDMC1_BANKID);
		}
		
	      // rusdraw bank sometimes is not present in the input events so it should be always added
	      addBankList(addBanks,RUSDRAW_BANKID);
		
	      // if the event has triggered then add the additional rufptn, rusdgeom banks
	      // which contain the results of pattern recognition and geometry fitting
	      if(ana->hasTriggered())
		{
		  addBankList(addBanks,RUFPTN_BANKID);
		  addBankList(addBanks,RUSDGEOM_BANKID);
		}
		
	      nevents_analyzed ++;
		
	    }
	  else
	    {
	      // if event is not analyzable ( doesn't have the necessary information) but has a MC (rusdmc) bank
	      // then still calculate the additional MC information from the thrown rusdmc variables
	      if (have_mc)
		{
		  // here we use a routine which excplicitly assumes that there is no source of refference time
		  // available from the SD information banks
		  ana->comp_rusdmc1_no_tref();
		  addBankList(addBanks,RUSDMC_BANKID);
		  addBankList(addBanks,RUSDMC1_BANKID);
		}
	    }
	    
	  // write out the event
	  if (!dstio->writeEvent(addBanks))
	    return 2;
	    
	  nevents_processed ++;
	    
	  if(opt.verbose > 0)
	    {
	      if (nevents_processed % 1000 == 0)
		{
		  fprintf(stdout, "events processed: %d\n",nevents_processed);
		  fflush(stdout);
		}
	    }
	} // while(dstio->readEvent ...
	
      // if all dst output goes to one file then close only the input file
      // otherwise, close input and output files
      if (opt.outfile[0])
	dstio->closeDSTinFile();
      else
	dstio->closeDSTfiles();

    } // while (infile = pullFile ... 
  
  fprintf(stdout, "rufptn_events_processed: %d rufptn_events_with_proper_banks: %d\n", 
	  nevents_processed,nevents_analyzed);
  
  // if all event output goes to one file then this is the place to 
  // close that output file
  if (opt.outfile[0])
    dstio->closeDSToutFile();
  
  fprintf(stdout, "\n\nDone\n");
  
  return 0;
  
}
